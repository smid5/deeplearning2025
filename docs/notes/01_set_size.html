<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Set Size Estimation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="shortcut icon" href="favicon.ico">
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GZHXTPTRRE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GZHXTPTRRE');
</script>
</head><body class="nav-fixed">\usepackage{amsbsy}

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">




<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">CSCI 1051 Winter 2025</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://middlebury.instructure.com/courses/16004"> 
<span class="menu-text">Canvas</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.gradescope.com/courses/934368"> 
<span class="menu-text">Gradescope</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-prior-years" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Prior Years</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-prior-years">    
        <li>
    <a class="dropdown-item" href="https://www.rtealwitter.com/deeplearning2023/">
 <span class="dropdown-text">Winter 2023</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Set Size Estimation</strong></h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Powered by repeated innovations in chip manufacturing, computers have grown exponentially more powerful over the last several decades. As a result, we have access to unparalleled computational resources and data. For example, a <a href="https://www.earthdata.nasa.gov/learn/articles/swot-calibration-validation">single NASA satellite</a> collects 20 terabytes of satellite images, more than 8 billion <a href="https://fitsmallbusiness.com/google-search-statistics/">searches</a> are made on Google, and <a href="https://explodingtopics.com/blog/data-generated-per-day">estimates</a> suggest the internet creates more than 300 million terabytes of data <em>every single day</em>. Simultaneously, we are quickly approaching the physical limit of how many transistors can be packed on a single chip. In order to learn from the data we have and continue expanding our computational abilities into the future, fast and efficient algorithms are more important than ever.</p>
<p>At first glance, an algorithm that performs only a few operations per item in our data set is efficient. However, these algorithms can be too slow when we have lots and lots of data. Instead, we turn to randomized algorithms that can run even faster. Randomized algorithms typically exploit some source of randomness to run on only a small part of the data set (or use only a small amount of space) while still returning an <em>approximately</em> correct result.</p>
<p>We can run randomized algorithms in practice to see how well they work. But we also want to <em>prove</em> that they work and understand why. Today, we will solve a problem using randomized algorithms. Before we get to the problems and algorithms, we’ll build some helpful probability tools.</p>
<section id="probability-background" class="level3">
<h3 class="anchored" data-anchor-id="probability-background">Probability Background</h3>
<p>Consider a random variable <span class="math inline">\(X\)</span>. For example, <span class="math inline">\(X\)</span> could be the outcome of a fair dice roll and be equal to <span class="math inline">\(1,2,3,4,5\)</span> or <span class="math inline">\(6\)</span>, each with probability <span class="math inline">\(\frac{1}{6}\)</span>. Formally, we use <span class="math inline">\(\Pr(X=x)\)</span> to represent the probability that the random variable <span class="math inline">\(X\)</span> is equal to the outcome <span class="math inline">\(x\)</span>. The expectation of a discrete random variable is <span class="math display">\[
\mathbb{E}[X] = \sum_{x} x \Pr(X=x).
\]</span> For example, the expected outcome of a fair dice roll is <span class="math inline">\(\mathbb{E}[X] = 1 \times \frac{1}{6} + 2 \times \frac{1}{6} + 3 \times \frac{1}{6} +
4 \times \frac{1}{6} + 5 \times \frac{1}{6} + 6 \times \frac{1}{6} = \frac{21}{6}\)</span>. Note: If the random variable is continuous, we can similarly define its expected value using an integral.</p>
<p>The expected value tells us where the random variable is on average but we’re also interested in how closely the random variable concentrates around its expectation. The variance of a random variable is <span class="math display">\[
\textrm{Var}[X] = \mathbb{E}\left[(X - \mathbb{E}[X])^2\right].
\]</span> Notice that the variance is larger when the random variable is often far from its expectation. In the figure below, can you identify the expected value for each of the three distributions? Which distribution has the largest variance? Which has the smallest?</p>
<center>
<img src="images/distributions.png" width="800">
</center>
<p>There are a number of useful facts about the expected value and variance. For example,</p>
<p><span class="math display">\[
\mathbb{E}[\alpha X] = \alpha \mathbb{E}[X]
\hspace{1em} \textrm{and} \hspace{1em}
\textrm{Var}(\alpha X) = \alpha^2 \textrm{Var}(X)
\]</span> where <span class="math inline">\(\alpha \in \mathbb{R}\)</span> is a real number. To see this, observe that <span class="math display">\[
\mathbb{E}[\alpha X] = \sum_{x} \alpha x \Pr(X=x)
= \alpha \sum_{x} x \Pr(X=x) = \alpha \mathbb{E}[X]
\]</span> and <span class="math display">\[
\textrm{Var}(\alpha X) = \sum_x (\alpha x - \alpha \mathbb{E}[X])^2 = \alpha^2 \sum_x ( x -  \mathbb{E}[X])^2
= \alpha^2 \textrm{Var}(X).
\]</span></p>
</section>
<section id="independent-random-variables" class="level3">
<h3 class="anchored" data-anchor-id="independent-random-variables">Independent Random Variables</h3>
<p>Once we have defined random variables, we are often interested in events defined on their outcomes. Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be two events. For example, <span class="math inline">\(A\)</span> could be the event that the dice shows <span class="math inline">\(1\)</span> or <span class="math inline">\(2\)</span> while <span class="math inline">\(B\)</span> could be the event that the dice shows an odd number. We use <span class="math inline">\(\Pr(A \cap B)\)</span> to denote the probability that events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> both happen. Often, we have information about one event and want to see how that changes the probability of another event. We use <span class="math inline">\(\Pr(A | B)\)</span> to denote the conditional probability of event <span class="math inline">\(A\)</span> given that <span class="math inline">\(B\)</span> happened. We define</p>
<p><span class="math display">\[
\Pr(A | B) = \frac{\Pr(A \cap B)}{\Pr(B)}.
\]</span></p>
<p>If information about event <span class="math inline">\(B\)</span> does not give us information about event <span class="math inline">\(A\)</span>, we say that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are independent. Formally, events <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are independent if <span class="math inline">\(\Pr(A|B) = \Pr(A)\)</span>. By the definition of conditional probability, an equivalent definition of independence is <span class="math inline">\(\Pr(A \cap B) = \Pr(A) \Pr(B)\)</span>.</p>
<p>Let’s figure out whether the event <span class="math inline">\(A\)</span> that the dice shows 1 or 2 is independent of the event <span class="math inline">\(B\)</span> that the dice shows an odd number. Well, <span class="math inline">\(\Pr(A \cap B) = \frac{1}{6}\)</span> since the only outcome that satisfy both events is when the dice shows a 1. We also know that <span class="math inline">\(\Pr(A) \Pr(B) = \frac{2}{6} \times \frac{3}{6} = \frac{1}{6}\)</span>. So, by the second definition of independence, we can conclude that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are independent.</p>
<p>We’ve been talking about events defined on random variables, but we’ll also be interested in when random variables are independent. Consider random variables <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. We say that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent if, for all outcomes <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, <span class="math inline">\(\Pr(X=x \cap Y=y) = \Pr(X=x) \Pr(Y=y)\)</span>.</p>
</section>
<section id="linearity-of-expectation" class="level3">
<h3 class="anchored" data-anchor-id="linearity-of-expectation">Linearity of Expectation</h3>
<p>One of the most powerful theorems in all of probability is the linearity of expectation.</p>
<p><strong>Theorem:</strong> Let <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> be random variables. Then <span class="math display">\[
\mathbb{E}[X+Y] = \mathbb{E}[X] + \mathbb{E}[Y].
\]</span> The result is a powerful tool that requires <em>no assumptions</em> on the random variables.</p>
<p><strong>Proof:</strong> Observe that <span class="math display">\[
\mathbb{E}[X+Y] = \sum_{x,y}(x+y) \Pr(X=x \cap Y=y)
\]</span> Now, we’ll separate the equation into two terms and factor out the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> terms, respectively. <span class="math display">\[
= \sum_x x \sum_y \Pr(X=x \cap Y=y)
+ \sum_y y \sum_x \Pr(X=x \cap Y=y)
\]</span> Finally, using the law of total probability, we have <span class="math display">\[
= \sum_x x \Pr(X=x) + \sum_y y \Pr(Y=y) = \mathbb{E}[X] + \mathbb{E}[Y].
\]</span></p>
<p>There are also several other useful facts about the expected value and variance.</p>
<p><strong>Fact 1:</strong> When <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent, <span class="math inline">\(\mathbb{E}[XY] = \mathbb{E}[X] \mathbb{E}[Y]\)</span>.</p>
<p><strong>Proof:</strong> Observe that <span class="math display">\[
\mathbb{E}[XY] = \sum_{x,y} xy \Pr(X=x \cap Y=y)
= \sum_{x,y} xy \Pr(X=x) \Pr(Y=y)
\]</span></p>
<p><span class="math display">\[
= \sum_x x \Pr(X=x) \sum_y y \Pr(Y=y)
= \mathbb{E}[X] \mathbb{E}[Y]
\]</span> where the second equality followed by the assumption that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent.</p>
<p><strong>Fact 2:</strong> Consider a random variable <span class="math inline">\(X\)</span>. Then <span class="math inline">\(\textrm{Var}(X) = \mathbb{E}[X^2] - \mathbb{E}[X]^2\)</span>.</p>
<p><strong>Proof:</strong> Observe that <span class="math display">\[
\textrm{Var}(X) =
\mathbb{E}[(X-\mathbb{E}[X])^2]
\]</span> <span class="math display">\[
= \mathbb{E}[X^2 - 2 X \mathbb{E}[X] + \mathbb{E}[X]^2]
= \mathbb{E}[X^2] - \mathbb{E}[X]^2
\]</span> where the first equality is by definition, the second equality is by foiling, and the third equality is by linearity of expectation and the observation that <span class="math inline">\(\mathbb{E}[X]\)</span> is a scaler.</p>
<p><strong>Fact 3:</strong> When <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent, <span class="math inline">\(\textrm{Var}(X+Y) = \textrm{Var}(X) + \textrm{Var}(Y)\)</span>.</p>
<p><strong>Proof:</strong> Observe that</p>
<p><span class="math display">\[\begin{align*}
\textrm{Var}(X+Y) &amp;= \mathbb{E}\left[(X + Y - \mathbb{E}[X] - \mathbb{E}[Y])^2\right] \\
&amp;= \mathbb{E}\left[(X- \mathbb{E}[X])^2 + 2(X-\mathbb{E}[X])(Y-\mathbb{E}[Y]) + (Y-\mathbb{E})^2\right] \\
&amp;= \textrm{Var}(X) + 2\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])]+ \textrm{Var}(Y).
\end{align*}\]</span> Then, when <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent, <span class="math display">\[
\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])]
= \mathbb{E}[XY - \mathbb{E}[X]Y - X\mathbb{E}[Y] + \mathbb{E}[X]\mathbb{E}[Y]] = 0
\]</span> where the last equality follows by Fact 1 when <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are independent.</p>
</section>
</section>
<section id="set-size-estimation" class="level2">
<h2 class="anchored" data-anchor-id="set-size-estimation">Set Size Estimation</h2>
<p>We’ll pose a problem that has applications in ecology, social networks, and internet indexing. However, while efficiently solving the problem is useful, our purpose is really to gain familiarity with linearity of expectation and learn Markov’s inequality.</p>
<p>Suppose you run a website that is considering contracting with a company to provide CAPTCHAs for login verification. The company claims to have a database with <span class="math inline">\(n=1000000\)</span> unique CAPTCHAs. For each API call, they’ll return a CAPTCHA chosen uniformly at random from their database. Here’s our problem: How many queries <span class="math inline">\(m\)</span> do we need to make to their API until we can independently verify that they do in fact have a million CAPTCHAs?</p>
<p>An obvious approach is to keep calling ther API until we find a million unique CAPTCHAs. Of course, the issue is that we have to make at least a million API calls. That’s not so good if we care about efficiency, they charge us per call, or the size they claim to have in their database is much bigger than a million.</p>
<p>A more clever approach is to call their API and count duplicates. Intuitively, the larger their database, the fewer duplicates we expect to see. Define a random variable <span class="math inline">\(D_{i,j}\)</span> which is 1 if the <span class="math inline">\(i\)</span>th and <span class="math inline">\(j\)</span>th calls return the same CAPTCHA and 0 otherwise. (To avoid double counting, we’ll assume <span class="math inline">\(i &lt; j\)</span>.) For example, in the figure below, the <span class="math inline">\(5\)</span>th, <span class="math inline">\(6\)</span>th, and <span class="math inline">\(7\)</span>th calls returned the same CAPTCHA so <span class="math inline">\(D_{5,6}\)</span>, <span class="math inline">\(D_{5,7}\)</span>, and <span class="math inline">\(D_{6,7}\)</span> are all 1.</p>
<center>
<img src="images/duplicates.png" width="800">
</center>
<p>When a random variable can only be 0 or 1, we call it an <em>indicator</em> random variable. Indicator random variables have the special property that their expected value is the probability they are 1. We can define the total number of duplicates <span class="math inline">\(D\)</span> in terms of our indicator random variables <span class="math inline">\(D_{i,j}\)</span>.</p>
<p><span class="math display">\[
D = \sum_{\substack{i, j \in \{1, \ldots, m\} \\ i &lt; j }} D_{i,j}
\]</span></p>
<p>We can calculate the expected number of duplicates using linearity of expectation.</p>
<p><span class="math display">\[
\mathbb{E}[D] = \sum_{\substack{i, j \in \{1, \ldots, m\} \\ i &lt; j }} \mathbb{E}[D_{i,j}]
\]</span></p>
<p>Since <span class="math inline">\(D_{i,j}\)</span> is an indicator random variable, we know <span class="math inline">\(\mathbb{E}[D_{i,j}]\)</span> is the probability the <span class="math inline">\(i\)</span>th and <span class="math inline">\(j\)</span>th CAPTCHA are the same. Since each API call is a uniform and independent sample from the database, the probability the <span class="math inline">\(j\)</span>th CAPTCHA is the same as the <span class="math inline">\(i\)</span>th is <span class="math inline">\(\frac{1}{n}\)</span>. With this observation in hand,</p>
<p><span class="math display">\[
\mathbb{E}[D] = \sum_{\substack{i, j \in \{1, \ldots, m\} \\ i &lt; j }} \frac{1}{n}
= \binom{m}{2} \frac{1}{n} = \frac{m(m-1)}{2n}.
\]</span></p>
<p>Suppose we take <span class="math inline">\(m=1000\)</span> queries and see <span class="math inline">\(D=10\)</span> duplicates. How does this compare to what we would expect if the database had <span class="math inline">\(n=1000000\)</span> CAPTCHAs?</p>
<p>Well, the expectation would be <span class="math inline">\(\mathbb{E}[D] = \frac{1000 \times 999}{2 \times 1000000} = .4995\)</span>. Something seems wrong… we observed many more duplicates than we expect. Can we formalize this intuition?</p>
<section id="markovs-inequality" class="level3">
<h3 class="anchored" data-anchor-id="markovs-inequality">Markov’s Inequality</h3>
<p>Concentration inequalities are a powerful tool in the analysis of randomized algorithms. They tell us how likely it is that a random variable differs from its expectation.</p>
<p>There are many concentration inequalities. Some apply in general and some apply only under special assumptions. The concentration inequalities that apply only under special assumptions tend to give stronger results. We’ll start with one of the most simple and general concentration inequalities.</p>
<p><strong>Theorem</strong>: For any non-negative random variable <span class="math inline">\(X\)</span> and any positive threshold <span class="math inline">\(t\)</span>, <span class="math display">\[
\Pr(X \geq t) \leq \frac{\mathbb{E}[X]}{t}.
\]</span></p>
<p><strong>Proof:</strong> We’ll prove the inequality directly. By the definition of expectation, we have <span class="math display">\[
\mathbb{E}[X] = \sum_{x} x \Pr(X=x)
= \sum_{\substack{x \\ x \geq t}} x \Pr(X=x) +
\sum_{\substack{x \\ x &lt; t}} x \Pr(X=x)
\]</span> <span class="math display">\[
\geq \sum_{\substack{x \\ x \geq t}} t \Pr(X=x) + 0
= t \Pr(X \geq t).
\]</span> Rearranging the above inequality gives Markov’s. Can you see where we used that all outcomes <span class="math inline">\(x\)</span> are non-negative?</p>
<p>Now let’s apply Markov’s inequality to our set size estimation problem. Since the number of duplicates <span class="math inline">\(D\)</span> is always positive, we satisfy the assumption of the inequality. <span class="math display">\[
\Pr(D \geq 10 ) \leq \frac{\mathbb{E}[D]}{10} = \frac{.4995}{10} = .04995
\]</span> The probability of observing the 10 duplicates is less than <span class="math inline">\(5\%\)</span>! We should probably start asking the CAPTCHA company some questions.</p>
<p>In practice, many of the set size estimation problems are slightly different. Instead of checking a claim about the set size, we want to estimate the set size directly. Notice that we computed <span class="math inline">\(\mathbb{E}[D] = \frac{m(m-1)}{2n}\)</span>. Rearranging, we see that <span class="math inline">\(n = \frac{m(m-1)}{2\mathbb{E}[D]}\)</span>. Given <span class="math inline">\(m\)</span> samples, we can naturally build an estimator for the whole set size using the empirical number of duplicates we found in the sample. With a little more work, we can show the following.</p>
<p><strong>Claim</strong>: If we make <span class="math inline">\(m \geq c \frac{\sqrt{n}}{\epsilon}\)</span> samples for a particular constant <span class="math inline">\(c\)</span>, then the estimate <span class="math inline">\(\hat{n} = \frac{m(m-1)}{2D}\)</span> satisfies <span class="math inline">\((1-\epsilon) n \leq \hat{n} \leq (1+\epsilon) n\)</span> with probability <span class="math inline">\(9/10\)</span>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>